# BitboardChess

## About
BitboardChess is an ongoing passion project that I started working on December 1st, 2022.

It is written from scratch in C++14. This project is meant to challenge myself and offer significant improvement to my first chess engine written
for the CS246 (Object-Oriented Software Development) end of term project.

For the sake academic integrity, I cannot release that project publicly. However, it is available upon request.

## How it works

Intuitively, when we think of representing a chess board, a 2D matrix of chess piece objects comes to mind naturally (an 8x8 array to represent each of the 64 squares). The advantage is that we can easily navigate between squares following their ranks and files. However, some major setbacks for this method of representation is that it is costly to store and very slow when it comes to move generation and evaluation.

Instead, unsigned 64-bit integers are used in this project where each bit corresponds to the state of a square on the board. Using this method, any board state can be represented with as few as twelve 64-bit numbers (one for each type of chess piece).

This is the method employed by essentially all modern chess engines such as Stockfish, AlphaZero, and many more.

What is great about bitboards is that it is information dense and leverages modern computers' 64-bit architecture to very efficiently perform parallel bitwise logical operations (XOR, AND, OR, NOT) in a single clock cycle.

Instead of evaluating move by move during runtime like many array-based engines, bitboard engines also precompute attack tables (bitboards that describe the squares accessible to a piece given any square) during initialization. Moves can be efficiently generated by referencing the precomputed attack (e.g  `attack_bb AND ~occupancy`).

A disadvantage of making a bitboard chess egine is that it isn't conceptually intuitive and is considered to be generally more difficult to develop and debug.

## Features

1. 64-bit Bitboard representation (for effective move storage, generation, and evaluation)
2. 16-bit move encoding (6 bits for source, 6 bits for target, and 4 bits for move type)
3. Magic-bitboard algorithm for sliding piece move generation (Bishop, Rook, Queen)
4. Demonstration of OOP principles with the use of Observer and MVC patterns

## Next Steps
- Implement UCI protocols to compare against other engines and obtain an accurate ELO evaluation
- Introduce an implementation of the ConcreteObserver for GUI (only text-based interection is supported at this time)
- Explore the use of various engine heuristics and techniques such as:
1. Piece square tables
2. Move ordering (Null, Killer, and History heuristics)
3. Negamax tree search
4. Transpositional table
5. (optionally) PolyGlot opening book support
